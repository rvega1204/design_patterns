# Design Patterns Examples

This repository contains basic examples of various design patterns implemented in Java. The goal is to provide a comprehensive resource for understanding and applying design patterns in software development.

## Table of Contents

- [Introduction](#introduction)
- [Creational Patterns](#creational-patterns)
- [Structural Patterns](#structural-patterns)
- [Behavioral Patterns](#behavioral-patterns)
- [Contributing](#contributing)
- [License](#license)

## Introduction

Design patterns are typical solutions to common problems in software design. They are like blueprints that can be customized to solve a particular design problem in your code. This repository includes examples of the following design patterns:

## Creational Patterns

1. **Singleton**: Ensures a class has only one instance and provides a global point of access to it.
2. **Factory Method**: Defines an interface for creating an object, but lets subclasses alter the type of objects that will be created.
3. **Abstract Factory**: Provides an interface for creating families of related or dependent objects without specifying their concrete classes.
4. **Builder**: Separates the construction of a complex object from its representation, allowing the same construction process to create various representations.
5. **Prototype**: Specifies the kinds of objects to create using a prototypical instance, and creates new objects by copying this prototype.

## Structural Patterns

1. **Adapter**: Allows incompatible interfaces to work together.
2. **Bridge**: Separates an object’s abstraction from its implementation so the two can vary independently.
3. **Composite**: Composes objects into tree structures to represent part-whole hierarchies.
4. **Decorator**: Adds additional responsibilities to an object dynamically.
5. **Facade**: Provides a simplified interface to a complex subsystem.
6. **Flyweight**: Reduces the cost of creating and manipulating a large number of similar objects.
7. **Proxy**: Provides a surrogate or placeholder for another object to control access to it.

## Behavioral Patterns

1. **Chain of Responsibility**: Passes a request along a chain of handlers.
2. **Command**: Encapsulates a request as an object, thereby allowing for parameterization and queuing of requests.
3. **Interpreter**: Implements a specialized language.
4. **Iterator**: Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.
5. **Mediator**: Defines an object that encapsulates how a set of objects interact.
6. **Memento**: Captures and externalizes an object’s internal state without violating encapsulation.
7. **Observer**: Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
8. **State**: Allows an object to alter its behavior when its internal state changes.
9. **Strategy**: Defines a family of algorithms, encapsulates each one, and makes them interchangeable.
10. **Template Method**: Defines the skeleton of an algorithm in an operation, deferring some steps to subclasses.
11. **Visitor**: Represents an operation to be performed on the elements of an object structure.

## Contributing

Contributions are welcome! You're free to add or update these examples.

## License

This project is licensed under the MIT License.